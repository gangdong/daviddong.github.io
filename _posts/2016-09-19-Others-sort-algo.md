---
layout: post
title:  "几种常见的排序算法"
date:   2016-09-19 19:04:30 +0800
categories: Others
---
记得很多年以前，在我研究生毕业找工作那会儿，面试的时候被面试官问到过两次关于排序算法的问题。这件事至今给我的印象比较深刻，因为很少有在不同的面试过程中会被问到相同的问题的情况。由此可见排序算法在面试中占有多大的比重了，其实这也是考察程序员的一个基础。前几天在招聘的过程中又想起了这件事，觉得虽然这个问题比较基础，但是还是有必要整理总结一下的。

大多数的人应该都能回答出冒泡排序和选择排序的算法，我想这可能是因为国内目前的教材中（比如「C语言编程基础」）这两种为例子的比较多的缘故吧。其实在后来的工作中了解到不止这两种算法，还有一些其他的算法也可以实现。当然能够回答出冒泡排序和选择排序也应该是合格的。下面我就来总结一下目前我所知道的常见的几种排序算法。

## 冒泡排序
我们就从最常见的冒泡排序来说起。为了统一起见，本文的排序都是以从小到大的序列为准。文中的例子都以`C`语言代码编写，我还提供了`python`和`Java`的源代码，有兴趣的可以在[这里]()里找到。
   
**冒泡排序规则是：从左到右，数组中相邻的两个元素进行比较，将较大的放到后面。**   
按照这个原则，我们编写代码。
      
**C语言实现**   
```c
void sort_bubble(int *a, int num)
{

    int i = 0;
    int j = 0;
    int temp = 0;

    for (i = 0; i < num - 1; i++)
    {
        for (int j = 0; j < num - i - 1; j++)
        {
            if (a[j] > a[j + 1])
            {
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
        printData(a, num);
    }
}
```
**打印结果如下**   
```c
initial data:
17,6,19,45,1,2,23,5,4,11,3,
options:1
starting bubble sort...
6,17,19,1,2,23,5,4,11,3,45,
6,17,1,2,19,5,4,11,3,23,45,
6,1,2,17,5,4,11,3,19,23,45,
1,2,6,5,4,11,3,17,19,23,45,
1,2,5,4,6,3,11,17,19,23,45,
1,2,4,5,3,6,11,17,19,23,45,
1,2,4,3,5,6,11,17,19,23,45,
1,2,3,4,5,6,11,17,19,23,45,
1,2,3,4,5,6,11,17,19,23,45,
1,2,3,4,5,6,11,17,19,23,45,
```
**结果分析**   
数组长度11，一共比较了10轮。第一轮比较结束后序列中最大数`45`从序列的最右边冒出来。第二轮比较后，所有数中第二大的那个数`23`就会浮到倒数第二个位置……就这样一轮一轮地比较，最后实现从小到大排序。

|轮次|比较次数|结果|
|---|:---:|---|
第1轮|10|6,17,19,1,2,23,5,4,11,3,`45`|
第2轮|9|6,17,1,2,19,5,4,11,3,`23`,~~45~~|
第3轮|8|6,1,2,17,5,4,11,3,`19`,~~23,45~~|
第4轮|7|1,2,6,5,4,11,3,`17`,~~19,23,45~~|
第5轮|6|1,2,5,4,6,3,`11`,~~17,19,23,45~~|
第6轮|5|1,2,4,5,3,`6`,~~11,17,19,23,45~~|
第7轮|4|1,2,4,3,`5`,~~6,11,17,19,23,45~~|
第8轮|3|1,2,3,`4`,~~5,6,11,17,19,23,45~~|
第9轮|2|1,2,`3`,~~4,5,6,11,17,19,23,45~~|
第10轮|1|1,`2`,~~3,4,5,6,11,17,19,23,45~~|

**时间/空间复杂度**   
由于我们要重复执行n次冒泡，每次冒泡要执行n次比较，也就是`O(n^2)`。 空间复杂度是`O(n)`。

## 选择排序
**选择排序规则是：从第一个位置开始比较，找出最小的，和第一个位置互换，开始下一轮。第二轮从第二个位置开始查找，然后找出剩余序列中最小的，和第二个位置互换，然后重复之前的操作，依次比较，直至所有数都排列完毕。**    
  
**C语言实现**       
```c
void sort_selection(int *a, int num)
{

    int i = 0;
    int j = 0;
    int temp = 0;
    int min;

    for (i = 0; i < num - 1; i++)
    {
        min = i;
        for (j = i + 1; j < num; j++)
        {
            if (a[j] < a[min])
            {
                min = j;
            }
        }
        temp = a[i];
        a[i] = a[min];
        a[min] = temp;
        printData(a, num);
    }
}
```
**打印结果**   
```c
initial data:
17,6,19,45,1,2,23,5,4,11,3,
options:2
starting selection...
1,6,19,45,17,2,23,5,4,11,3,
1,2,19,45,17,6,23,5,4,11,3,
1,2,3,45,17,6,23,5,4,11,19,
1,2,3,4,17,6,23,5,45,11,19,
1,2,3,4,5,6,23,17,45,11,19,
1,2,3,4,5,6,23,17,45,11,19,
1,2,3,4,5,6,11,17,45,23,19,
1,2,3,4,5,6,11,17,45,23,19,
1,2,3,4,5,6,11,17,19,23,45,
1,2,3,4,5,6,11,17,19,23,45,
```
**结果分析**   
也是一共比较了10轮。第一轮比较结束后序列中最小数`a[4]` 和`a[0]`互换。第二轮从`a[1]`开始比较，因为`a[0]`已经是最小的数了，比较完成后，`a[1]~a[10]`中最小的数`a[5]`和`a[1]`互换。依次论推，直到把数据排列好。

|轮次|比较次数|结果|
|---|:---:|---|
第1轮|10|`1`,6,19,45,`17`,2,23,5,4,11,3|
第2轮|9|~~1,~~`2`,19,45,17,`6`,23,5,4,11,3|
第3轮|8|~~1,2,~~`3`,45,17,6,23,5,4,11,`19`|
第4轮|7|~~1,2,3,~~`4`,17,6,23,5,`45`,11,19|
第5轮|6|~~1,2,3,4,~~`5`,6,23,`17`,45,11,19|
第6轮|5|~~1,2,3,4,5,~~`6`,`23`,17,45,11,19|
第7轮|4|~~1,2,3,4,5,6,~~`11`,17,45,`23`,19|
第8轮|3|~~1,2,3,4,5,6,11,~~17,45,23,19|
第9轮|2|~~1,2,3,4,5,6,11,17,~~`19`,23,`45`|
第10轮|1|~~1,2,3,4,5,6,11,17,19,~~23,45|

**时间/空间复杂度**    
每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是`O(n^2)`。空间复杂度是`O(n)`。

## 快速排序
**快速排序规则是：选择序列中的一个数为基准数，序列中的数逐个与之比较，小的放到它的左边，大的放大它的右边，然后再对左右区间递归执行上述步骤，直至各区间只有一个数。**  