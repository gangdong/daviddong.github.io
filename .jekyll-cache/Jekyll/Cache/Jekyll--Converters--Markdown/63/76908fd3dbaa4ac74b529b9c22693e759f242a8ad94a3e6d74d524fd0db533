I"(e<p>Following the last two articles…</p>

<h2 id="7-managing-queues-in-a-wbdi-driver"><span id="7">7. Managing Queues in a WBDI Driver</span></h2>
<p>WBDI drivers should create at least one queue to handle multiple concurrent requests from the service. If you are using UMDF, you can take advantage of its queue management support.</p>

<p>In WudfBioUsbSample, the CBiometricIoQueue class implements the I/O queue interface.</p>

<p>In the method <code class="language-plaintext highlighter-rouge">CBiometricIoQueue::Initialize</code>, specifically, the driver queries the owning <code class="language-plaintext highlighter-rouge">CBiometricIoQueue</code> object for a pointer to the <code class="language-plaintext highlighter-rouge">IQueueCallbackDeviceIoControl</code> interface that the framework uses to determine the event callback functions that the driver subscribes to on the queue:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">if</span> <span class="p">(</span><span class="no">SUCCEEDED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span> 
<span class="p">{</span>
    <span class="n">hr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="no">QueryInterface</span><span class="p">(</span><span class="n">__uuidof</span><span class="p">(</span><span class="no">IUnknown</span><span class="p">),</span> <span class="p">(</span><span class="n">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">unknown</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Then the driver calls <code class="language-plaintext highlighter-rouge">IWDFDevice::CreateIoQueue</code> to configure the default I/O queue:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">hr</span> <span class="o">=</span> <span class="no">FxDevice</span><span class="o">-&gt;</span><span class="no">CreateIoQueue</span><span class="p">(</span><span class="n">unknown</span><span class="p">,</span><span class="no">FALSE</span><span class="p">,</span><span class="no">WdfIoQueueDispatchParallel</span><span class="p">,</span><span class="no">FALSE</span><span class="p">,</span><span class="no">FALSE</span><span class="p">,</span><span class="o">&amp;</span><span class="n">fxQueue</span><span class="p">);</span>
<span class="no">BiometricSafeRelease</span><span class="p">(</span><span class="n">unknown</span><span class="p">);</span></code></pre></figure>

<p>The call specifies <code class="language-plaintext highlighter-rouge">WdfIoQueueDispatchParallel</code> so that the framework will present requests to the driver’s I/O queue callback functions as soon as the requests are available.</p>

<p>Next, the driver calls <code class="language-plaintext highlighter-rouge">IWDFDevice::ConfigureRequestDispatching</code> to configure the queue to filter all Device I/O requests:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">hr</span> <span class="o">=</span> <span class="no">FxDevice</span><span class="o">-&gt;</span><span class="no">ConfigureRequestDispatching</span><span class="p">(</span><span class="n">fxQueue</span><span class="p">,</span><span class="no">WdfRequestDeviceIoControl</span><span class="p">,</span><span class="no">TRUE</span><span class="p">);</span></code></pre></figure>

<p>Because the driver specifies <code class="language-plaintext highlighter-rouge">WdfRequestDeviceIoControl</code> in this call, it provides an OnDeviceIoControl handler to process I/O notifications from the framework. It does this in the <code class="language-plaintext highlighter-rouge">IQueueCallbackDeviceIoControl::OnDeviceIoControl</code> method that is part of the “unknown” parameter in the call to <code class="language-plaintext highlighter-rouge">CreateIoQueue</code> previously.</p>

<p>There can only be one outstanding <code class="language-plaintext highlighter-rouge">IOCTL_BIOMETRIC_CAPTURE_DATA</code> request at a time. The driver should track <code class="language-plaintext highlighter-rouge">IOCTL_BIOMETRIC_CAPTURE_DATA</code> requests, either by internally keeping a pointer to the pending requests or by using another framework queue to handle those requests.</p>

<p>In the sample, if there is a pending I/O request, the sample maintains a pointer to the request in a member of the CBiometricDevice class, as defined in Device.h:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">IWDFIoRequest</span> <span class="o">*</span><span class="n">m_PendingRequest</span><span class="p">;</span></code></pre></figure>

<p>While one sensor data collection I/O is pending, subsequent calls to the data collection IOCTLs should fail:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">FxRequest</span><span class="o">-&gt;</span><span class="no">Complete</span><span class="p">(</span><span class="no">WINBIO_E_DATA_COLLECTION_IN_PROGRESS</span><span class="p">);</span></code></pre></figure>

<p>When a capture request is completed or canceled, this value is set to NULL:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">IWDFIoRequest</span> <span class="o">*</span><span class="no">FxRequest</span> <span class="o">=</span> <span class="p">(</span><span class="no">IWDFIoRequest</span> <span class="o">*</span><span class="p">)</span><span class="no">InterlockedExchangePointer</span><span class="p">((</span><span class="no">PVOID</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">m_PendingRequest</span><span class="p">,</span> <span class="no">NULL</span><span class="p">);</span></code></pre></figure>

<h2 id="8-installing-a-biometric-driver"><span id="8">8. Installing a Biometric Driver</span></h2>
<p>Vendors can provide an INF file to install a WBDI driver.</p>

<p>The following is a list of guidelines for biometric device installation. The code examples in this topic are taken from the <code class="language-plaintext highlighter-rouge">WudfBioUsbSample.inx</code> file of the <a href="https://github.com/Microsoft/Windows-driver-samples/tree/master/biometrics/driver">WudfBioUsbSample</a>:</p>

<ul>
  <li>WBDI drivers should specify a class of “Biometric.” Set ClassGuid equal to the value that corresponds to <code class="language-plaintext highlighter-rouge">GUID_DEVCLASS_BIOMETRIC</code> in Devguid.h:</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="p">[</span><span class="no">Version</span><span class="p">]</span>
<span class="no">Signature</span><span class="o">=</span><span class="s2">"$Windows NT$"</span>
<span class="no">Class</span><span class="o">=</span><span class="no">Biometric</span>
<span class="no">ClassGuid</span><span class="o">=</span><span class="p">{</span><span class="mi">53</span><span class="no">D29EF7</span><span class="o">-</span><span class="mi">377</span><span class="no">C</span><span class="o">-</span><span class="mi">4</span><span class="no">D14</span><span class="o">-</span><span class="mi">864</span><span class="no">B</span><span class="o">-</span><span class="no">EB3A85769359</span><span class="p">}</span></code></pre></figure>

<ul>
  <li>In your .HW section, provide AddReg directives to specify three sections that contain entries to be added to the registry:</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="p">[</span><span class="no">Biometric_Install</span><span class="o">.</span><span class="no">NT</span><span class="p">.</span><span class="nf">hw</span><span class="p">]</span>
<span class="no">AddReg</span><span class="o">=</span><span class="no">Biometric_Device_AddReg</span>
<span class="no">AddReg</span><span class="o">=</span><span class="no">DriverPlugInAddReg</span><span class="p">,</span> <span class="no">DatabaseAddReg</span></code></pre></figure>

<ul>
  <li>Provide the named sections referred to in the .HW section. The <code class="language-plaintext highlighter-rouge">[Biometric_Device_AddReg]</code> section sets values for the biometric device, including the exclusive flag and system wake/device idle. To be recognized by Windows Biometric Framework, UMDF-based WBDI drivers must set the “Exclusive” value to 1. The first two lines of the <code class="language-plaintext highlighter-rouge">[Biometric_Device_AddReg]</code> section specify access control list (ACL) rights so that the device can only be opened by an administrator or the local system account. When you specify these ACL rights, third-party applications cannot open the device and capture fingerprint data when the WinBio service is not running. For example:</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="p">[</span><span class="no">Biometric_Device_AddReg</span><span class="p">]</span>
<span class="no">HKR</span><span class="p">,,</span><span class="s2">"DeviceCharacteristics"</span><span class="p">,</span><span class="mh">0x10001</span><span class="p">,</span><span class="mh">0x0100</span>     <span class="p">;</span> <span class="no">Use</span> <span class="n">same</span> <span class="n">security</span> <span class="n">checks</span> <span class="n">on</span> <span class="n">relative</span> <span class="n">opens</span>
<span class="no">HKR</span><span class="p">,,</span><span class="s2">"Security"</span><span class="p">,,</span><span class="s2">"D:P(A;;GA;;;BA)(A;;GA;;;SY)"</span>  <span class="p">;</span> <span class="no">Allow</span> <span class="n">generic</span><span class="o">-</span><span class="n">all</span> <span class="n">access</span> <span class="n">to</span> <span class="no">Built</span><span class="o">-</span><span class="k">in</span> <span class="n">administrators</span> <span class="n">and</span> <span class="no">Local</span> <span class="nb">system</span>
<span class="no">HKR</span><span class="p">,,</span><span class="s2">"LowerFilters"</span><span class="p">,</span><span class="mh">0x00010008</span><span class="p">,</span><span class="s2">"WinUsb"</span> <span class="p">;</span> <span class="no">FLG_ADDREG_TYPE_MULTI_SZ</span> <span class="o">|</span> <span class="no">FLG_ADDREG_APPEND</span>
<span class="no">HKR</span><span class="p">,,</span><span class="s2">"Exclusive"</span><span class="p">,</span><span class="mh">0x10001</span><span class="p">,</span><span class="mi">1</span>
<span class="no">HKR</span><span class="p">,,</span><span class="s2">"SystemWakeEnabled"</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mi">1</span>
<span class="no">HKR</span><span class="p">,,</span><span class="s2">"DeviceIdleEnabled"</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mi">1</span>
<span class="no">HKR</span><span class="p">,,</span><span class="s2">"UserSetDeviceIdleEnabled"</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mi">1</span>
<span class="no">HKR</span><span class="p">,,</span><span class="s2">"DefaultIdleState"</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mi">1</span>
<span class="no">HKR</span><span class="p">,,</span><span class="s2">"DefaultIdleTimeout"</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mi">5000</span></code></pre></figure>

<p>A WBDI driver that exposes functionality to a legacy (non-WBDI) biometric stack should set the Exclusive value to zero. If this value is set to zero, the Windows Biometric Framework does not attempt to control the device and the device is not exposed through WBF.</p>

<p>Vendors can have a single driver binary that can work with legacy stacks and WBF, but the two cannot operate simultaneously. WBF will only operate if the device can be opened with exclusive access.</p>

<ul>
  <li>The second named section contains registry values for the plug-in adapters. The sample uses the Microsoft-provided sensor adapter and storage adapter. This section also enables Windows log-in support by setting the SystemSensor value:</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="p">[</span><span class="no">DriverPlugInAddReg</span><span class="p">]</span>
<span class="no">HKR</span><span class="p">,</span><span class="no">WinBio</span><span class="p">\</span><span class="no">Configurations</span><span class="p">,</span><span class="no">DefaultConfiguration</span><span class="p">,,</span><span class="s2">"0"</span>
<span class="no">HKR</span><span class="p">,</span><span class="no">WinBio</span><span class="p">\</span><span class="no">Configurations</span><span class="p">\</span><span class="mi">0</span><span class="p">,</span><span class="no">SensorMode</span><span class="p">,</span><span class="mh">0x10001</span><span class="p">,</span><span class="mi">1</span>                                <span class="p">;</span> <span class="no">Basic</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="no">Advanced</span> <span class="o">-</span> <span class="mi">2</span>
<span class="no">HKR</span><span class="p">,</span><span class="no">WinBio</span><span class="p">\</span><span class="no">Configurations</span><span class="p">\</span><span class="mi">0</span><span class="p">,</span><span class="no">SystemSensor</span><span class="p">,</span><span class="mh">0x10001</span><span class="p">,</span><span class="mi">1</span>                              <span class="p">;</span> <span class="no">UAC</span><span class="o">/</span><span class="no">Winlogon</span> <span class="o">-</span> <span class="mi">1</span>
<span class="no">HKR</span><span class="p">,</span><span class="no">WinBio</span><span class="p">\</span><span class="no">Configurations</span><span class="p">\</span><span class="mi">0</span><span class="p">,</span><span class="no">SensorAdapterBinary</span><span class="p">,,</span><span class="s2">"WinBioSensorAdapter.DLL"</span>      <span class="p">;</span> <span class="no">Windows</span> <span class="n">built</span><span class="o">-</span><span class="k">in</span> <span class="no">WBDI</span> <span class="n">sensor</span> <span class="n">adapter</span><span class="o">.</span>
<span class="no">HKR</span><span class="p">,</span><span class="no">WinBio</span><span class="p">\</span><span class="no">Configurations</span><span class="p">\</span><span class="mi">0</span><span class="p">,</span><span class="no">EngineAdapterBinary</span><span class="p">,,</span><span class="s2">"EngineAdapter.DLL"</span>            <span class="p">;</span> <span class="no">Vendor</span> <span class="n">engine</span>
<span class="no">HKR</span><span class="p">,</span><span class="no">WinBio</span><span class="p">\</span><span class="no">Configurations</span><span class="p">\</span><span class="mi">0</span><span class="p">,</span><span class="no">StorageAdapterBinary</span><span class="p">,,</span><span class="s2">"WinBioStorageAdapter.DLL"</span>    <span class="p">;</span> <span class="no">Windows</span> <span class="n">built</span><span class="o">-</span><span class="k">in</span> <span class="n">storage</span> <span class="n">adapter</span>
<span class="no">HKR</span><span class="p">,</span><span class="no">WinBio</span><span class="p">\</span><span class="no">Configurations</span><span class="p">\</span><span class="mi">0</span><span class="p">,</span><span class="no">DatabaseId</span><span class="p">,,</span><span class="s2">"6E9D4C5A-55B4-4c52-90B7-DDDC75CA4D50"</span>  <span class="p">;</span> <span class="no">Unique</span> <span class="n">database</span> <span class="no">GUID</span></code></pre></figure>

<ul>
  <li>Finally, the third section sets the following registry values for the database service. The identifying GUID must be unique for each vendor database of a certain format. For instance, in this code example from the sample, change <code class="language-plaintext highlighter-rouge">6E9D4C5A-55B4-4c52-90B7-DDDC75CA4D50</code> to your own unique GUID in your INF file.</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="p">[</span><span class="no">DatabaseAddReg</span><span class="p">]</span>
<span class="no">HKLM</span><span class="p">,</span><span class="no">System</span><span class="p">\</span><span class="no">CurrentControlSet</span><span class="p">\</span><span class="no">Services</span><span class="p">\</span><span class="no">WbioSrvc</span><span class="p">\</span><span class="no">Databases</span><span class="p">\{</span><span class="mf">6E9</span><span class="no">D4C5A</span><span class="o">-</span><span class="mi">55</span><span class="no">B4</span><span class="o">-</span><span class="mi">4</span><span class="n">c52</span><span class="o">-</span><span class="mi">90</span><span class="no">B7</span><span class="o">-</span><span class="no">DDDC75CA4D50</span><span class="p">},</span><span class="no">BiometricType</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mh">0x00000008</span>
<span class="no">HKLM</span><span class="p">,</span><span class="no">System</span><span class="p">\</span><span class="no">CurrentControlSet</span><span class="p">\</span><span class="no">Services</span><span class="p">\</span><span class="no">WbioSrvc</span><span class="p">\</span><span class="no">Databases</span><span class="p">\{</span><span class="mf">6E9</span><span class="no">D4C5A</span><span class="o">-</span><span class="mi">55</span><span class="no">B4</span><span class="o">-</span><span class="mi">4</span><span class="n">c52</span><span class="o">-</span><span class="mi">90</span><span class="no">B7</span><span class="o">-</span><span class="no">DDDC75CA4D50</span><span class="p">},</span><span class="no">Attributes</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mh">0x00000001</span>
<span class="no">HKLM</span><span class="p">,</span><span class="no">System</span><span class="p">\</span><span class="no">CurrentControlSet</span><span class="p">\</span><span class="no">Services</span><span class="p">\</span><span class="no">WbioSrvc</span><span class="p">\</span><span class="no">Databases</span><span class="p">\{</span><span class="mf">6E9</span><span class="no">D4C5A</span><span class="o">-</span><span class="mi">55</span><span class="no">B4</span><span class="o">-</span><span class="mi">4</span><span class="n">c52</span><span class="o">-</span><span class="mi">90</span><span class="no">B7</span><span class="o">-</span><span class="no">DDDC75CA4D50</span><span class="p">},</span><span class="no">Format</span><span class="p">,,</span><span class="s2">"00000000-0000-0000-0000-000000000000"</span>
<span class="no">HKLM</span><span class="p">,</span><span class="no">System</span><span class="p">\</span><span class="no">CurrentControlSet</span><span class="p">\</span><span class="no">Services</span><span class="p">\</span><span class="no">WbioSrvc</span><span class="p">\</span><span class="no">Databases</span><span class="p">\{</span><span class="mf">6E9</span><span class="no">D4C5A</span><span class="o">-</span><span class="mi">55</span><span class="no">B4</span><span class="o">-</span><span class="mi">4</span><span class="n">c52</span><span class="o">-</span><span class="mi">90</span><span class="no">B7</span><span class="o">-</span><span class="no">DDDC75CA4D50</span><span class="p">},</span><span class="no">InitialSize</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mh">0x00000020</span>
<span class="no">HKLM</span><span class="p">,</span><span class="no">System</span><span class="p">\</span><span class="no">CurrentControlSet</span><span class="p">\</span><span class="no">Services</span><span class="p">\</span><span class="no">WbioSrvc</span><span class="p">\</span><span class="no">Databases</span><span class="p">\{</span><span class="mf">6E9</span><span class="no">D4C5A</span><span class="o">-</span><span class="mi">55</span><span class="no">B4</span><span class="o">-</span><span class="mi">4</span><span class="n">c52</span><span class="o">-</span><span class="mi">90</span><span class="no">B7</span><span class="o">-</span><span class="no">DDDC75CA4D50</span><span class="p">},</span><span class="no">AutoCreate</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mh">0x00000001</span>
<span class="no">HKLM</span><span class="p">,</span><span class="no">System</span><span class="p">\</span><span class="no">CurrentControlSet</span><span class="p">\</span><span class="no">Services</span><span class="p">\</span><span class="no">WbioSrvc</span><span class="p">\</span><span class="no">Databases</span><span class="p">\{</span><span class="mf">6E9</span><span class="no">D4C5A</span><span class="o">-</span><span class="mi">55</span><span class="no">B4</span><span class="o">-</span><span class="mi">4</span><span class="n">c52</span><span class="o">-</span><span class="mi">90</span><span class="no">B7</span><span class="o">-</span><span class="no">DDDC75CA4D50</span><span class="p">},</span><span class="no">AutoName</span><span class="p">,</span><span class="mh">0x00010001</span><span class="p">,</span><span class="mh">0x00000001</span>
<span class="no">HKLM</span><span class="p">,</span><span class="no">System</span><span class="p">\</span><span class="no">CurrentControlSet</span><span class="p">\</span><span class="no">Services</span><span class="p">\</span><span class="no">WbioSrvc</span><span class="p">\</span><span class="no">Databases</span><span class="p">\{</span><span class="mf">6E9</span><span class="no">D4C5A</span><span class="o">-</span><span class="mi">55</span><span class="no">B4</span><span class="o">-</span><span class="mi">4</span><span class="n">c52</span><span class="o">-</span><span class="mi">90</span><span class="no">B7</span><span class="o">-</span><span class="no">DDDC75CA4D50</span><span class="p">},</span><span class="no">FilePath</span><span class="p">,,</span><span class="s2">""</span>
<span class="no">HKLM</span><span class="p">,</span><span class="no">System</span><span class="p">\</span><span class="no">CurrentControlSet</span><span class="p">\</span><span class="no">Services</span><span class="p">\</span><span class="no">WbioSrvc</span><span class="p">\</span><span class="no">Databases</span><span class="p">\{</span><span class="mf">6E9</span><span class="no">D4C5A</span><span class="o">-</span><span class="mi">55</span><span class="no">B4</span><span class="o">-</span><span class="mi">4</span><span class="n">c52</span><span class="o">-</span><span class="mi">90</span><span class="no">B7</span><span class="o">-</span><span class="no">DDDC75CA4D50</span><span class="p">},</span><span class="no">ConnectionString</span><span class="p">,,</span><span class="s2">""</span></code></pre></figure>

<p>For information about INX files and how they differ from INF files, see Using INX Files to Create INF Files.</p>

<h2 id="9-creating-a-device-interface-for-a-wbdi-driver"><span id="9">9. Creating a Device Interface for a WBDI Driver</span></h2>
<p>After the device callback object has been initialized and returned to the driver, at the time of queue setup, the driver should create a device interface instance for the biometric device.</p>

<p>Specifically, WBDI drivers must expose the <code class="language-plaintext highlighter-rouge">GUID_DEVINTERFACE_BIOMETRIC_READER</code> device interface by calling <code class="language-plaintext highlighter-rouge">IWDFDevice::CreateDeviceInterface</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">hr</span> <span class="o">=</span> <span class="n">m_FxDevice</span><span class="o">-&gt;</span><span class="no">CreateDeviceInterface</span><span class="p">(</span><span class="o">&amp;</span><span class="no">GUID_DEVINTERFACE_BIOMETRIC_READER</span><span class="p">,</span> <span class="no">NULL</span><span class="p">);</span></code></pre></figure>

<p>This call is followed by a call to <code class="language-plaintext highlighter-rouge">IWDFDevice::AssignDeviceInterfaceState</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">hr</span> <span class="o">=</span> <span class="n">m_FxDevice</span><span class="o">-&gt;</span><span class="no">AssignDeviceInterfaceState</span><span class="p">(</span><span class="o">&amp;</span><span class="no">GUID_DEVINTERFACE_BIOMETRIC_READER</span><span class="p">,</span><span class="no">NULL</span><span class="p">,</span><span class="no">TRUE</span><span class="p">);</span></code></pre></figure>

<p>A WBDI driver that wants to expose functionality to a legacy (non-WBDI) biometric stack should expose another device interface for legacy applications and make sure that the Exclusive value is set to zero in the INX file that installs the legacy stack.</p>

<p>Exposing the <code class="language-plaintext highlighter-rouge">GUID_DEVINTERFACE_BIOMETRIC_READER</code> device interface causes the WBF service to enumerate the driver only. If Exclusive mode is not set, WBF does not attempt to open and control the device.</p>

<p>Alternatively, the driver could detect internally that it is in legacy mode and then not expose the <code class="language-plaintext highlighter-rouge">GUID_DEVINTERFACE_BIOMETRIC_READER</code> device interface.</p>
:ET